% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Reduce.R
\name{applyf}
\alias{applyf}
\alias{\%|.\%}
\alias{\%.|\%}
\title{Use function to reduce or expand arguments.}
\usage{
applyf(f, args, env = parent.frame())

f \%|.\% args

args \%.|\% f
}
\arguments{
\item{f}{function.}

\item{args}{argument list or vector, entries expanded as function arguments.}

\item{env}{environment to execute in.}
}
\value{
f(args) where args elements become individual arguments of f.
}
\description{
\code{applyf} is a wrapper for \code{\link[base]{do.call}} that also accepts argument vectors.
The operator versions \code{\%.|\%} and \code{\%|.\%} are mere syntactic sugar.
In all cases any these functions are sufficient to pass arguments from a list to a variadic
function (such as \code{\link[base]{sum}}). The operator symbols are meant to invoke non-tilted
versions of APL's reduce and expand operators.
}
\section{Functions}{
\itemize{
\item \code{\%|.\%}: f reduce args

\item \code{\%.|\%}: args expand f
}}

\examples{

# basic examples
c(1, 2, 3) \%.|\% sum
c(1, 2, 3) \%.|\% base::sum
c(1, 2, 3) \%.|\% function(...) { sum(...) }

# simulate partial application of log(5, base=2)
5 \%.>\% applyf(log, list(., base = 2))

# # simluate partial application with dplyr
# # can be used with dplyr/rlang as follows
# d <- data.frame(x=1, y=2, z=3)
# syms <- rlang::syms(c("x", "y"))
# d \%.>\% applyf(dplyr::select, c(list(.), syms))

}
\seealso{
\code{\link[base]{do.call}}
}
